import numpy as np
import networkx as nx
# ==================== Nodal methods =======================


def calc_nodal_partition(G):
    '''
    Returns nodal_partition, module_partition

    where nodal_partition represents a nodal partition of graph G generated by
    the community module as a dictionary of node: module pairs.
    module_partition represents the same partition as a dictionary of
    module: [list of nodes] pairs.


    Note that this is a time intensive process and it is also
    non-deterministic, so for consistency and speed it's best
    to save a partition.
    '''
    import community
    # Make sure the edges are binarized
    for u, v, d in G.edges(data=True):
        if d['weight'] != 1:
            raise ValueError("input should be a binary graph")
    # Now calculate the best partition
    nodal_partition = community.best_partition(G)

    # Reverse the dictionary to record a list of nodes per module, rather than
    # module per node
    module_partition = {}
    for n, m in nodal_partition.items():
        try:
            module_partition[m].append(n)
        except KeyError:
            module_partition[m] = [n]

    return nodal_partition, module_partition


def participation_coefficient(G, module_partition):
    '''
    Computes the participation coefficient of nodes of G with partition
    defined by module_partition.
    (Guimera et al. 2005).

    - G is a networkx graph
    - module_partition is a dictionary mapping community names to lists of
     nodes in G

    Returns a dictionary mapping the nodes of G to their participation
    coefficient under module_partition.
    '''
    # Initialise dictionary for the participation coefficients
    pc_dict = {}

    # Print a little note to the screen because it can take a long
    # time to run this code
    print('        Calculating participation coefficient -\
           may take a little while')
    # Loop over modules to calculate participation coefficient for each node
    for m in module_partition.keys():
        mod_list = set(module_partition[m])
        for source in mod_list:
            # Calculate the degree for the 'source' node
            degree = nx.degree(G=G, nbunch=source)

            # Calculate the number of intramodule edges
            wm_edges = 0
            for target in mod_list:
                if (source, target) in G.edges():
                    wm_edges += 1

            # The participation coeficient is 1 - the square of
            # the ratio of the within module degree and the total degree
            pc = 1 - ((float(wm_edges) / float(degree))**2)

            pc_dict[source] = pc

    return pc_dict


def assign_nodal_distance(G):
    '''
    G is a networkx graph with nodal attribute 'centroids' defined for each
    node. The value of 'centroids' should be the cartesian coordinates of
    each node.

    Using the centroids data, calculates the following

    Edge attributes:
    - euclidean: the euclidean length of each edge

    Node attributes:
    - total_dist: the total length of the incident edges for each node
    - average_dist: the average length of the incident edges for each node

    Returns G with modified node and edge attributes
    '''
    from scipy.spatial import distance
    for i, node in enumerate(G.nodes()):
        # Loop through the edges connecting to this node
        # Note that "node1" is equal to "node"
        for node1, node2 in G.edges(nbunch=[node]):

            # Calculate the euclidean distance for this edge
            cent1 = G.node[node1]['centroids']
            cent2 = G.node[node2]['centroids']

            dist = distance.euclidean(cent1, cent2)

            # And assign this value to the edge
            G.adj[node1][node2]['euclidean'] = dist

        # Create two nodal attributes (average distance and
        # total distance) by summarizing the euclidean distance
        # for all edges which connect to the node
        euc_list = [G.adj[m][n]['euclidean'] for m, n in G.edges(nbunch=node)]

        G.node[node]['average_dist'] = np.mean(euc_list)
        G.node[node]['total_dist'] = np.sum(euc_list)
    return G


def assign_interhem(G):
    '''
    An edge is considered interhemispheric if the x coordinates of its nodes
    have different signs.
    Calculates the following edge and node attributes:

    Edge attributes:
    - interhem: 1 if the edge is interhemispheric, 0 otherwise.

    Node attributes:
    - interhem: the number of adjacent interhemispheric edges
    - interhem_proportion: the proportion of the adjacent edges that are
        interhemispheric

    G is a networkx graph with an 'x' or a 'centroids' attribute defined for
    each node.

    Returns G with modified node and edge attributes
    '''
    for i, node in enumerate(G.nodes()):
        for node1, node2 in G.edges(nbunch=[node]):
            # Determine whether this edge is interhemispheric
            # by multiplying the x values.
            try:
                x1 = G.node[node1]['x']
                x2 = G.node[node2]['x']
            except KeyError:
                x1 = G.node[node1]['centroids'][0]
                x2 = G.node[node2]['centroids'][0]

            # Determine whether this edge is interhemispheric
            # by multiplying the x values.
            if x1*x2 > 0:
                G.adj[node1][node2]['interhem'] = 0
            else:
                G.adj[node1][node2]['interhem'] = 1

        # Create an interhem nodal attribute by getting the average
        # of the interhem values for all edges which connect to the node
        interhem_list = [G.adj[m][n]['interhem']
                         for m, n in G.edges(nbunch=node)]
        G.node[node]['interhem_proportion'] = np.mean(interhem_list)
    return G


def shortest_path(G):
    '''
    Returns a dictionary mapping a node v to the average length of the shortest
    from v to other nodes in G. Not that in this case "length" means the number
    of edges in this path, and not the euclidean distance.

    G is a connected graph
    '''
    shortestpl_dict_dict = dict(nx.shortest_path_length(G))

    shortestpl_dict = {}

    for node in G.nodes():
        shortestpl_dict[node] = np.average(
                                list(shortestpl_dict_dict[node].values()))
    return shortestpl_dict


# ============= Global measures =============


def calc_modularity(G, nodal_partition):
    '''
    Returns the network modularity of G under the
    modules defined by nodal_partition.

    G is a graph and nodal_partition is a partition
    of G indexed by node
    '''
    import community
    return community.modularity(nodal_partition, G)


def calc_efficiency(G):
    '''
    Returns the global efficiency of G
    '''
    E = 0.0
    for node in G:
        path_length = nx.single_source_shortest_path_length(G, node)
        E += 1.0/sum(path_length.values())
    return E


def rich_club(G):
    return nx.rich_club_coefficient(G, normalized=False)


def calculate_global_measures(G, partition):
    # ==== MEASURES ====================
    global_measures = {}

    # ---- Clustering coefficient ------
    global_measures['average_clustering'] = (
        nx.average_clustering(G))

    # ---- Shortest path length --------
    global_measures['average_shortest_path_length'] = (
        nx.average_shortest_path_length(G))

    # ---- Assortativity ---------------
    global_measures['assortativity'] = (
        np.mean(nx.degree_assortativity_coefficient(G)))

    # ---- Modularity ------------------
    global_measures['modularity'] = (
        calc_modularity(G, partition))

    #  ---- Efficiency ------------------
    global_measures['efficiency'] = (
        calc_efficiency(G))

    # ---- Small world -----------------
    # not sure, think this should move on down the line
    sigma_array = np.ones(n)
    for i in range(n):
        sigma_array[i] = ((global_measures['C']
                           / global_measures['C_rand'][i])
                          / (global_measures['L']
                             / global_measures['L_rand'][i]))
    global_measures['sigma'] = sigma_array
    global_measures['sigma_rand'] = 1.0
    return global_measures
